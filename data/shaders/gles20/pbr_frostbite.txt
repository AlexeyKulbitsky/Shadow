float Fr_DisneyDiffuse ( float NdotV , float NdotL , float LdotH , float linearRoughness )
{
	float energyBias = lerp (0 , 0.5 , linearRoughness );
	float energyFactor = lerp (1.0 , 1.0 / 1.51 , linearRoughness );
	float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness ;
	float3 f0 = float3 (1.0 f , 1.0 f , 1.0 f);
	float lightScatter = F_Schlick ( f0 , fd90 , NdotL ) .r;
	float viewScatter = F_Schlick (f0 , fd90 , NdotV ).r;

	return lightScatter * viewScatter * energyFactor ;
}



float3 F_Schlick (in float3 f0 , in float f90 , in float u )
{
	return f0 + ( f90 - f0 ) * pow (1. f - u , 5. f);
}

float V_SmithGGXCorrelated ( float NdotL , float NdotV , float alphaG )
{
	// Original formulation of G_SmithGGX Correlated
	// lambda_v = ( -1 + sqrt ( alphaG2 * (1 - NdotL2 ) / NdotL2 + 1)) * 0.5 f;
	// lambda_l = ( -1 + sqrt ( alphaG2 * (1 - NdotV2 ) / NdotV2 + 1)) * 0.5 f;
	// G_SmithGGXCorrelated = 1 / (1 + lambda_v + lambda_l );
	// V_SmithGGXCorrelated = G_SmithGGXCorrelated / (4.0 f * NdotL * NdotV );

	// This is the optimize version
	float alphaG2 = alphaG * alphaG ;
	// Caution : the " NdotL *" and " NdotV *" are explicitely inversed , this is not a mistake .
	float Lambda_GGXV = NdotL * sqrt (( - NdotV * alphaG2 + NdotV ) * NdotV + alphaG2 );
	float Lambda_GGXL = NdotV * sqrt (( - NdotL * alphaG2 + NdotL ) * NdotL + alphaG2 );

	return 0.5 f / ( Lambda_GGXV + Lambda_GGXL );
}

float D_GGX ( float NdotH , float m )
{
	// Divide by PI is apply later
	float m2 = m * m ;
	float f = ( NdotH * m2 - NdotH ) * NdotH + 1;
	return m2 / (f * f) ;
}

// This code is an example of call of previous functions
float NdotV = abs( dot (N , V )) + 1e -5 f; // avoid artifact
float3 H = normalize (V + L);
float LdotH = saturate ( dot (L , H ));
float NdotH = saturate ( dot (N , H ));
float NdotL = saturate ( dot (N , L ));

// Specular BRDF
float3 F = F_Schlick (f0 , f90 , LdotH );
float Vis = V_SmithGGXCorrelated ( NdotV , NdotL , roughness );
float D = D_GGX ( NdotH , roughness );
float Fr = D * F * Vis / PI ;

// Diffuse BRDF
float Fd = Fr_DisneyDiffuse ( NdotV , NdotL , LdotH , linearRoughness ) / PI ;


f0 = 0.16 * reflectance * reflectance;
f90 = saturate (50.0 * dot ( f0 , 0.33) );
f90 = 0.5 + cos(theta) * cos(theta) * roughness;

f90 = saturate (50.0 * dot ( fresnel0 , 0.33) );

float3 F_Schlick (in float3 f0 , in float f90 , in float u )
{
	return f0 + ( f90 - f0 ) * pow (1. f - u , 5. f);
}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////


 void importanceSampleCosDir ( in float2 u , in float3 N , out float3 L , out float NdotL , out float pdf )
{
	// Local referencial
	float3 upVector = abs( N.z) < 0.999 ? float3 (0 ,0 ,1) : float3 (1 ,0 ,0) ;
	float3 tangentX = normalize ( cross ( upVector , N ) );
	float3 tangentY = cross ( N , tangentX );

	float u1 = u.x ;
	float u2 = u.y ;

	float r = sqrt ( u1 );
	float phi = u2 * FB_PI * 2;

	L = float3 (r* cos ( phi ) , r* sin ( phi ) , sqrt (max (0.0 f ,1.0 f - u1 )) );
	L = normalize ( tangentX * L.y + tangentY * L .x + N * L.z) ;

	NdotL = dot (L ,N) ;
	pdf = NdotL * FB_INV_PI ;
}

float4 integrateDFGOnly ( in float3 V , in float3 N , in float roughness )
{
	float NdotV = saturate ( dot (N , V ));
	float4 acc = 0;
	float accWeight = 0;

	// Compute pre - integration
	Referential referential = createReferential (N);
	for ( uint i =0; i < sampleCount ; ++ i )
	{
		float2 u = getSample (i , sampleCount );
		float3 L = 0;

		float NdotH = 0;
		float LdotH = 0;
		float G = 0;

		// See [ Karis13 ] for implementation
		importanceSampleGGX_G (u , V , N , referential , roughness , NdotH , LdotH , L , G);

		// specular GGX DFG preIntegration
		float NdotL = saturate ( dot (N , L) );
		if ( NdotL >0 && G > 0.0)
		{
			float GVis = G * LdotH / ( NdotH * NdotV );
			float Fc = pow (1 - LdotH , 5. f);
			acc .x += (1 - Fc ) * GVis ;
			acc .y += Fc * GVis ;
		}

		// diffuse Disney preIntegration
		u = frac ( u + 0.5) ;
		float pdf ;
		importanceSampleCosDir (u , N , L , NdotL , pdf );
		if ( NdotL >0)
		{
			float LdotH = saturate ( dot (L , normalize (V + L));
			float NdotV = saturate ( dot (N , V) );
			acc .z += Fr_DisneyDiffuse ( NdotV , NdotL , LdotH , sqrt ( roughness ));
		}

		accWeight += 1.0;
	}

	return acc * (1.0 f / accWeight );
}




float3 evaluateIBLDiffuse (...)
{
	float3 dominantN = getDiffuseDominantDir (N , V , NdotV , roughness ) ;
	float3 diffuseLighting = diffuseLD . Sample ( sampler , dominantN );

	float diffF = DFG . SampleLevel ( sampler , float2 ( NdotV , roughness ) , 0) .z;

	return diffuseLighting * diffF ;
}

float3 evaluateIBLSpecular (...)
{
	float3 dominantR = getSpecularDominantDir (N , R , NdotV , roughness );

	// Rebuild the function
	// L . D. ( f0.Gv .(1 - Fc) + Gv.Fc ) . cosTheta / (4 . NdotL . NdotV )
	NdotV = max ( NdotV , 0.5 f/ DFG_TEXTURE_SIZE );
	float mipLevel = linearRoughnessToMipLevel ( linearRoughness , mipCount ) ;
	float3 preLD = specularLD . SampleLevel ( sampler , dominantR , mipLevel ). rgb ;

	// Sample pre - integrate DFG
	// Fc = (1 -H.L)^5
	// PreIntegratedDFG .r = Gv .(1 - Fc)
	// PreIntegratedDFG .g = Gv.Fc
	float2 preDFG = DFG . SampleLevel ( sampler , float2 ( NdotV , roughness ) , 0) . xy ;

	// LD . ( f0.Gv .(1 - Fc) + Gv.Fc. f90 )
	return preLD * ( f0 * preDFG . x + f90 * preDFG .y );
}


float3 DirectionWS = PositionWS - CameraWS;
float3 ReflDirectionWS = reflect(DirectionWS, NormalWS);

// Following is the parallax-correction code
// Find the ray intersection with box plane
float3 FirstPlaneIntersect = (BoxMax - PositionWS) / ReflDirectionWS;
float3 SecondPlaneIntersect = (BoxMin - PositionWS) / ReflDirectionWS;
// Get the furthest of these intersections along the ray
// (Ok because x/0 give +inf and -x/0 give â€“inf )
float3 FurthestPlane = max(FirstPlaneIntersect, SecondPlaneIntersect);
// Find the closest far intersection
float Distance = min(min(FurthestPlane.x, FurthestPlane.y), FurthestPlane.z);

// Get the intersection position
float3 IntersectPositionWS = PositionWS + ReflDirectionWS * Distance;
// Get corrected reflection
ReflDirectionWS = IntersectPositionWS - CubemapPositionWS;
// End parallax-correction code

return texCUBE(envMap, ReflDirectionWS);
