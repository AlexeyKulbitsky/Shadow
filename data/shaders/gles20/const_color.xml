<technique name="ConstantColor">

<pipeline name="firstPass" layer="main">
	<constants>
		<uniforms>
			<uniform name="matWorld" type="mat4" val="model.worldMatrix"/>
			<uniform name="matMVP" type="mat4" val="model.worldViewProjectionMatrix"/>
			<uniform name="lightDirection" type="vec3Array" val="light.directional.direction"/>
			<uniform name="color" type="float" val="1.0"/>
		</uniforms>


		<constant name="matWorld" type="mat4" />
		<constant name="matMVP" type="mat4" />
		<constant name="lightDirection" type="vec3" />
		<constant name="color" type="float" />

	</constants>
	
	<attributes>
		<position 	type="vec3" name="aPosition"/>
		<!--normal		type="vec3" name="aNormal"/-->
	</attributes>
	
	<shader language="GLSL" api="GLES20">
		<vertexShader>
		<source>
			<![CDATA[

				attribute vec3 aPosition;
				attribute vec3 aNormal;
				uniform mat4 matMVP;
				uniform mat4 matWorld;
				
				varying vec3 vNormal;
				
				void main() 
				{
					gl_Position = matMVP * vec4(aPosition, 1.0);
					//vNormal = (matWorld * vec4(aNormal, 0.0)).xyz;
					vNormal = mat3(matWorld) * aNormal;
				}
				
			]]>
		</source>
		</vertexShader>

		<fragmentShader>
		<source>
			<![CDATA[

				precision mediump float;
				uniform float color;
				uniform vec3 lightDirection[8];

				varying vec3 vNormal;

				void main() 
				{				
					vec3 N = normalize(vNormal);
					vec3 L = normalize(lightDirection[0]);
					float NdotL = dot(N, L);
					vec3 light = NdotL * vec3(1.0);
					light = light * vec3(color);
					gl_FragColor = vec4(light, 1.0);
				} 
		
			]]>	
		</source>
		</fragmentShader>
	</shader>
	
	<!-- VULKAN SHADER/-->
	<shader language="SPIR-V" api="Vulkan">
		<vertexShader>
			<constants>
			</constants>
			<source val="vert.spv">
				<![CDATA[

					#version 450
					#extension GL_ARB_separate_shader_objects : enable

					layout (std140, push_constant) uniform PushConsts 
					{
						mat4 MVP;
					} pushConsts;

					layout(location = 0) in vec3 aPosition;

					void main() 
					{
						gl_Position = pushConsts.MVP * vec4(aPosition, 1.0);
					}
				
				]]>
			</source>
		</vertexShader>
		
		<fragmentShader>
			<constants>
			</constants>
			<source val="frag.spv">
				<![CDATA[

					#version 450
					#extension GL_ARB_separate_shader_objects : enable

					layout(location = 0) out vec4 outColor;

					void main() 
					{
						outColor = vec4(1.0, 0.0, 0.0, 1.0);
					}
		
				]]>	
			</source>
		</fragmentShader>
	
	</shader>

</pipeline>

<!--pipeline name="tecnicalPass" layer="main">	
	<constants>
		<uniforms>
			<uniform name="color" type="vec4"/>
			<uniform name="matMVP" type="mat4" val="model.worldViewProjectionMatrix"/>

			<constant name="matMVP" type="mat4" />
		</uniforms>
	</constants>
	
	<attributes>
		<position 	type="vec3" name="aPosition"/>
	</attributes>
	
	<shader language="GLSL" api="GLES20">
		<vertexShader>
		<source>
			<![CDATA[

				attribute vec3 aPosition;
				uniform mat4 matMVP;
				
				void main() 
				{
					gl_Position = matMVP * vec4(aPosition, 1.0);
				}
				
			]]>
		</source>
		</vertexShader>

		<fragmentShader>
		<source>
			<![CDATA[

				precision mediump float;
		
				uniform vec4 color;
		
				void main() 
				{				
					gl_FragColor = vec4(color);
				} 
		
			]]>	
		</source>
		</fragmentShader>
	</shader>
</pipeline-->

</technique>